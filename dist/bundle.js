/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/chess_engine.ts":
/*!*****************************!*\
  !*** ./src/chess_engine.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.chess_game = exports.Game_board = exports.Piece = exports.typeColToDepict = exports.colors = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nexports.colors = [\"white\", \"black\"];\nexports.typeColToDepict = {\n    \"white\": {\n        \"pawn\": \"♙\",\n        \"rook\": \"♖\",\n        \"knight\": \"♘\",\n        \"bishop\": \"♗\",\n        \"queen\": \"♕\",\n        \"king\": \"♔\",\n        \"empty\": \"E\"\n    },\n    \"black\": {\n        \"pawn\": \"♟\",\n        \"rook\": \"♜\",\n        \"knight\": \"♞\",\n        \"bishop\": \"♝\",\n        \"queen\": \"♛\",\n        \"king\": \"♚\",\n        \"empty\": \"E\"\n    },\n};\nclass Piece {\n    constructor(type, col, pos) {\n        this.position = pos;\n        this.type = type;\n        this.color = col;\n        if (col == null) {\n            this.depict = \"E\";\n        }\n        else {\n            this.depict = exports.typeColToDepict[col][type];\n        }\n    }\n    to_string() {\n        return this.depict;\n    }\n}\nexports.Piece = Piece;\nclass Game_board {\n    constructor() {\n        this.board = [];\n        this.set_starting_position();\n    }\n    set_empty() {\n        this.board = Array(8).fill(null).map(() => Array(8).fill(null));\n        for (let i = 0; i < 8; i++) {\n            for (let j = 0; j < 8; j++) {\n                this.board[i][j] = new Piece(\"empty\", null, [i, j]);\n            }\n        }\n    }\n    place_piece(pieceType, pieceColor, position) {\n        if (this.isValidPosition(position)) {\n            this.board[position[0]][position[1]] = new Piece(pieceType, pieceColor, position);\n        }\n        else {\n            console.error(\"Invalid position for piece placement\");\n        }\n    }\n    get_free_positions() {\n        let free_positions = [];\n        for (let i = 0; i < 8; i++) {\n            for (let j = 0; j < 8; j++) {\n                if (this.board[i][j].depict == \"E\") {\n                    free_positions.push([i, j]);\n                }\n            }\n        }\n        return free_positions;\n    }\n    set_starting_position() {\n        for (let i = 0; i < 8; i++) {\n            this.board[i] = []; // Initialize the row\n            for (let j = 0; j < 8; j++) {\n                if (i === 1) {\n                    this.place_piece(\"pawn\", \"white\", [i, j]); // White pawns// Black pawns\n                }\n                else if (i === 6) {\n                    this.place_piece(\"pawn\", \"black\", [i, j]); // White pawns // White pawns\n                }\n                else if (i === 0 || i === 7) {\n                    let color;\n                    let types = [\"rook\", \"knight\", \"bishop\", \"queen\", \"king\", \"bishop\", \"knight\", \"rook\"];\n                    ;\n                    if (i === 0) {\n                        color = \"white\";\n                    }\n                    else { // i === 7\n                        color = \"black\";\n                    }\n                    const pieceOrder = [0, 1, 2, 3, 4, 2, 1, 0];\n                    this.place_piece(types[pieceOrder[j]], color, [i, j]);\n                }\n                else {\n                    this.place_piece(\"empty\", null, [i, j]); // Empty square\n                }\n            }\n        }\n    }\n    getPiecesByColor(color) {\n        let pieces = this.get_all_board_pieces();\n        pieces = pieces.filter(piece => piece.color === color);\n        return pieces;\n    }\n    isValidPosition(position) {\n        return position[0] >= 0 && position[0] < 8 && position[1] >= 0 && position[1] < 8;\n    }\n    print() {\n        for (let i = 0; i < 8; i++) {\n            console.log(this.board[i].map(piece => piece.depict).join(\" \") + \" \" + String(i));\n        }\n        console.log(\"0 1 2 3 4 5 6 7\");\n        /* console.log(\"info about piece color\") //for debugging\n        for (let i = 0; i < 8; i++) {\n            console.log(this.board[i].map(piece => piece.color).join(\" \") + \" \" + String(i));\n        }\n        console.log(\"0 1 2 3 4 5 6 7\");  */\n    }\n    get_all_board_pieces() {\n        let pieces = []; //pieces as string\n        for (let i = 0; i < 8; i++) {\n            for (let j = 0; j < 8; j++) {\n                let piece = this.board[i][j];\n                if (piece.depict != \"E\") {\n                    pieces.push(piece);\n                }\n            }\n        }\n        return pieces;\n    }\n    get_possible_moves(piece) {\n        //console.log(\"piece\", piece, piece.depict, \"position\", piece.position);\n        let possible_moves = [];\n        const calculateMove = (direction, pawn) => {\n            let [dx, dy] = direction;\n            let x = piece.position[0] + dx, y = piece.position[1] + dy;\n            if (!this.isValidPosition([x, y])) {\n                //console.log(\"not valid position\", [x, y])\n                return false;\n            }\n            if (piece.color != null && this.getPiecesByColor(piece.color).includes(this.board[x][y])) {\n                //console.log(\"piece of same color, returning false\", [x, y])\n                return false;\n            }\n            if (this.board[x][y].depict == \"E\") {\n                if (pawn) {\n                    if (dy != 0) {\n                        return false;\n                    }\n                }\n                possible_moves.push([x, y]);\n                return true;\n            }\n            else {\n                // take piece if it is of the other color\n                if (piece.color != null && !this.getPiecesByColor(piece.color).includes(this.board[x][y])) {\n                    //console.log(\"adding position can claim enemy piece\", [x, y])\n                    possible_moves.push([x, y]);\n                    //console.log(\"take piece\", [x, y]);\n                    return false;\n                }\n                else {\n                    // if the piece is of the same color, don't add the move and return false\n                    return false;\n                }\n            }\n        };\n        if (piece.type == \"pawn\") {\n            if (piece.color == \"white\") {\n                var directions = [[1, 0], [1, -1], [1, 1]]; //black\n            }\n            else {\n                var directions = [[-1, 0], [-1, -1], [-1, 1]];\n            }\n            // Forward, forward left diagonal, forward right diagonal.\n            for (let direction of directions) {\n                calculateMove(direction, true);\n            }\n            // Handle 2 steps forward for the pawn's first move\n            //to step forward fix readability\n            if ((piece.position[0] === 1 && this.board[piece.position[0] + 2][piece.position[1]].depict === \"E\") ||\n                (piece.position[0] === 6 && this.board[piece.position[0] - 2][piece.position[1]].depict === \"E\")) {\n                possible_moves.push([piece.position[0] + (piece.color === \"white\" ? 2 : -2), piece.position[1]]);\n            }\n            return possible_moves;\n        }\n        if (piece.type == \"rook\") {\n            const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]; // Up, down, right, left\n            for (let direction of directions) {\n                let steps = 1;\n                while (calculateMove(direction.map(num => num * steps))) {\n                    steps++;\n                }\n            }\n            return possible_moves;\n        }\n        if (piece.type == \"knight\") {\n            const directions = [[1, 2], [-1, 2], [1, -2], [-1, -2], [2, 1], [-2, 1], [2, -1], [-2, -1]]; // L shape\n            for (let direction of directions) {\n                calculateMove(direction);\n            }\n            return possible_moves;\n        }\n        if (piece.type == \"bishop\") {\n            const directions = [[1, 1], [-1, 1], [1, -1], [-1, -1]]; // Diagonals\n            for (let direction of directions) {\n                let steps = 1;\n                while (calculateMove(direction.map(num => num * steps))) {\n                    steps++;\n                }\n            }\n            return possible_moves;\n        }\n        if (piece.type == \"queen\") {\n            const directions = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]]; // Up, down, right, left, diagonals\n            for (let direction of directions) {\n                let steps = 1;\n                while (calculateMove(direction.map(num => num * steps))) {\n                    steps++;\n                }\n            }\n            return possible_moves;\n        }\n        if (piece.type == \"king\") {\n            const directions = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]]; // Up, down, right, left, diagonals\n            for (let direction of directions) {\n                calculateMove(direction);\n            }\n            return possible_moves;\n        }\n        else {\n            return [];\n        }\n    }\n    find_all(piece) {\n        //console.log(\"finding piece\", piece);\n        let positions = [];\n        for (let i = 0; i < 8; i++) {\n            for (let j = 0; j < 8; j++) {\n                if (this.board[i][j].depict == piece.depict) { //cannot compare pieces directly\n                    positions.push([i, j]);\n                }\n            }\n        }\n        if (positions.length == 0) {\n            return [[]];\n        }\n        return positions;\n    }\n    move(piece, target_position) {\n        let candidates = this.get_possible_moves(piece);\n        //console.log(\"target position\", target_position)\n        //console.log(piece)\n        //console.log(\"candidates\", candidates);\n        if (!(0, utils_1.includesArray)(candidates, target_position)) {\n            throw new Error(`Invalid move for ${piece.type} at ${piece.position} to ${target_position}`);\n        }\n        let [x, y] = target_position;\n        let [old_x, old_y] = piece.position;\n        this.place_piece(piece.type, piece.color, [x, y]);\n        this.place_piece(\"empty\", null, [old_x, old_y]);\n        console.log(this.board[old_x][old_y]);\n    }\n    all_moves(color) {\n        const pieces_by_color = this.getPiecesByColor(color);\n        let potential_moves = [];\n        pieces_by_color.forEach((piece) => {\n            var possible_moves = this.get_possible_moves(piece);\n            potential_moves.push(...possible_moves);\n        });\n        return potential_moves;\n    }\n    check_threat(color) {\n        let enemy_col = color === \"white\" ? \"black\" : \"white\";\n        let enemy_moves = this.all_moves(enemy_col);\n        let pieces = this.getPiecesByColor(color); // get pieces\n        let kings = pieces.filter(p => p.type === \"king\" && p.color === color);\n        if (kings.length === 0) {\n            console.log('No king found! on this board.');\n            this.print();\n            throw new Error(`No king of color ${color} found!`);\n        }\n        let king_position = kings[0].position;\n        //console.log(\"enemy moves\", enemy_moves)\n        //console.log(\"king position\", king_position)\n        for (let move of enemy_moves) {\n            if ((0, utils_1.includesArray)([move], king_position)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.Game_board = Game_board;\nclass chess_game {\n    constructor() {\n        this.active_piece = null;\n        this.Game_board = new Game_board();\n        this.simulation_board = new Game_board();\n    }\n    checkmate(color) {\n        this.simulation_board.board = JSON.parse(JSON.stringify(this.Game_board.board)); //deep copy to avoid object referencing issues\n        if (this.simulation_board.check_threat(color)) {\n            console.log(\"threatened\");\n            let pieces = this.Game_board.getPiecesByColor(color);\n            let isCheckmate = true;\n            for (let piece of pieces) {\n                let moves = this.Game_board.get_possible_moves(piece);\n                //console.log(\"moves\", moves)\n                for (let move of moves) {\n                    // copy the real board to the simulation board\n                    this.simulation_board.board = JSON.parse(JSON.stringify(this.Game_board.board));\n                    /* console.log(\"piece\", piece, \"move\", move)\n                    console.log(\"position before move\", piece.position, move)\n                    console.log(\"all pieces\", this.Game_board.get_all_board_pieces())\n                    console.log(\"pieces by color\", color, this.simulation_board.getPiecesByColor(color))\n                    console.log(\"pieces by color\", 'white' ? 'black' : 'white' , this.simulation_board.getPiecesByColor(color)) */\n                    this.simulation_board.move(piece, move);\n                    /* console.log(\"position after\", piece.position)\n                    console.log(\"board after\")\n                    this.simulation_board.print()\n                    console.log(\"threatened\" ,this.simulation_board.check_threat(color)) */\n                    if (!this.simulation_board.check_threat(color)) {\n                        // if not, then it's not checkmate\n                        isCheckmate = false;\n                        break;\n                    }\n                    if (!isCheckmate)\n                        break;\n                }\n                if (!isCheckmate)\n                    break;\n            }\n            return isCheckmate;\n        }\n        return false;\n    }\n    restart() {\n        this.Game_board.set_starting_position();\n        this.simulation_board.set_starting_position();\n    }\n}\nexports.chess_game = chess_game;\n//TODOS:\n//move works\n//fix checkmate\n//rewrite how simulation is done\n// fix double king bug\n//en passant, castling, promotion when pawn reaches end of board\n\n\n//# sourceURL=webpack://typescript-test/./src/chess_engine.ts?");

/***/ }),

/***/ "./src/interface.ts":
/*!**************************!*\
  !*** ./src/interface.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst chess_engine_1 = __webpack_require__(/*! ./chess_engine */ \"./src/chess_engine.ts\"); //remember to add .js to interface.js\n// Create a new game board\nvar game = new chess_engine_1.chess_game();\ngame.Game_board.set_empty();\ngame.Game_board.place_piece('king', 'white', [0, 0]);\ngame.Game_board.place_piece('queen', 'black', [0, 1]);\ngame.Game_board.place_piece('queen', 'black', [1, 1]);\nlet active_col = 'white';\nfunction init_state() {\n    let chessboardDiv = document.getElementById('chess-board');\n    if (chessboardDiv) {\n        chessboardDiv.innerHTML = '';\n        game.Game_board.board.forEach((row, i) => {\n            row.forEach((cell, j) => {\n                // Create a new div for the square\n                const squareDiv = document.createElement('div');\n                if (cell.depict != 'E') {\n                    const piece = document.createTextNode(cell.depict);\n                    squareDiv.appendChild(piece);\n                }\n                else {\n                    const piece = document.createTextNode('');\n                    squareDiv.appendChild(piece);\n                }\n                // Set the class for the square\n                squareDiv.classList.add('square');\n                if ((i + j) % 2 === 0) {\n                    squareDiv.classList.add('white');\n                }\n                else {\n                    squareDiv.classList.add('black');\n                }\n                // If there's a piece in this square, add a class for it\n                if (cell.depict !== 'E') {\n                    squareDiv.classList.add(cell.type);\n                    //squareDiv.classList.add(piece_class.color);\n                }\n                // Set the data attributes for the row and column\n                squareDiv.setAttribute('data-row', i.toString());\n                squareDiv.setAttribute('data-col', j.toString());\n                // Add the square to the chessboard\n                if (chessboardDiv) { // check for null value\n                    chessboardDiv.appendChild(squareDiv);\n                }\n            });\n        });\n    }\n    check_for_checkmate(game, active_col);\n    setUpSquareClickEvents();\n}\nfunction check_for_checkmate(game, active_col) {\n    if (game.checkmate(active_col)) {\n        console.log('checkmate');\n        let messageDiv = document.getElementById('message');\n        if (messageDiv) { // ensure that the messageDiv is not null\n            let opposite_col = active_col === \"white\" ? \"black\" : \"white\";\n            messageDiv.innerHTML = `<h2>Checkmate! ${opposite_col} wins!</h2>`;\n            setTimeout(() => {\n                if (messageDiv)\n                    messageDiv.innerHTML = '';\n            }, 1500);\n            let countdown = 5;\n            let countdownInterval = setInterval(() => {\n                if (messageDiv) {\n                    if (countdown > 0) {\n                        messageDiv.innerHTML = `<h2>Game restarts in ${countdown} seconds</h2>`;\n                        countdown--;\n                    }\n                    else {\n                        messageDiv.innerHTML = '';\n                        clearInterval(countdownInterval); // stop the interval\n                        // reset the game and call init_state()\n                        game.restart();\n                        active_col = 'white';\n                        init_state();\n                    }\n                }\n            }, 1000);\n        }\n    }\n    else {\n        console.log('not checkmate');\n    }\n}\nfunction setUpSquareClickEvents() {\n    let squares = document.querySelectorAll('.square');\n    if (squares) {\n        squares.forEach(square => {\n            square.addEventListener(\"click\", (event) => {\n                let [x, y] = get_coordinates(square);\n                console.log(`coordinates, row: ${x}, col: ${y}`);\n                if (game.Game_board.board[x][y].color !== active_col && game.active_piece === null) {\n                    let message2 = document.getElementById('message2');\n                    if (message2) {\n                        message2.innerHTML = `<h2>It is not ${game.Game_board.board[x][y].color}'s turn</h2>`;\n                        // Remove the message after 5 seconds (5000 milliseconds)\n                        setTimeout(() => {\n                            if (message2)\n                                message2.innerHTML = '';\n                        }, 1500);\n                    }\n                    return;\n                }\n                if (square.classList.contains('active')) {\n                    console.log('remove square from active');\n                    square.classList.remove('active');\n                    // find square that is confirmed\n                    const confirmed_square = document.querySelector('.confirm');\n                    if (confirmed_square) {\n                        confirmed_square.classList.remove('confirm');\n                    }\n                    remove_possible_moves(game);\n                    console.log('removing from active piece');\n                    setUpSquareClickEvents();\n                }\n                if (square.classList.contains('possible-move')) {\n                    console.log('square is possible move');\n                    square.classList.add('confirm');\n                    square.classList.remove('possible-move');\n                    return;\n                }\n                if (square.classList.contains('confirm')) {\n                    console.log('square is confirmed');\n                    square.classList.remove('confirm');\n                    remove_possible_moves(game);\n                    if (game.active_piece) {\n                        if (game.active_piece.position) {\n                            game.Game_board.move(game.active_piece, [x, y]);\n                        }\n                        game.active_piece = null;\n                        active_col = active_col === 'white' ? 'black' : 'white';\n                        init_state();\n                    }\n                    else {\n                        throw new Error('active_piece is null');\n                    }\n                    return;\n                }\n                if (square.classList.contains('white') || square.classList.contains('black')) {\n                    let [x, y] = get_coordinates(square);\n                    let picked_pos = game.Game_board.board[x][y];\n                    if (picked_pos.depict === 'E') {\n                        console.log('empty square');\n                    }\n                    else {\n                        game.active_piece = picked_pos;\n                        square.classList.add('active');\n                        //console.log(`active piece: ${game.active_piece.type}`)\n                        visualize_possible_moves(game, game.active_piece);\n                    }\n                    return;\n                }\n            });\n        });\n    }\n}\nfunction visualize_possible_moves(game, piece) {\n    const possible_moves = game.Game_board.get_possible_moves(piece);\n    console.log(\"here are the possible moves: \" + possible_moves);\n    possible_moves.forEach(move => {\n        const square = document.querySelector(`[data-row=\"${move[0]}\"][data-col=\"${move[1]}\"]`);\n        if (square) {\n            square.classList.add('possible-move');\n        }\n    });\n}\nfunction remove_possible_moves(game) {\n    const possible_moves = document.querySelectorAll('.possible-move');\n    possible_moves.forEach(move => {\n        move.classList.remove('possible-move');\n    });\n    console.log('all possible moves removed');\n}\nfunction get_coordinates(square) {\n    let rowAttr = square.getAttribute('data-row');\n    let colAttr = square.getAttribute('data-col');\n    console.log(`row: ${rowAttr}, col: ${colAttr}`);\n    if (rowAttr !== null && colAttr !== null) {\n        var x = parseInt(rowAttr, 10);\n        var y = parseInt(colAttr, 10);\n        console.log(`coordinates, row: ${x}, col: ${y}`);\n    }\n    else {\n        throw new Error('row or col is null');\n    }\n    return [x, y];\n}\ninit_state();\n\n\n//# sourceURL=webpack://typescript-test/./src/interface.ts?");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.includesArray = void 0;\nfunction includesArray(candidates, target) {\n    return candidates.some(candidate => candidate.length === target.length &&\n        candidate.every((value, index) => value === target[index]));\n}\nexports.includesArray = includesArray;\n\n\n//# sourceURL=webpack://typescript-test/./src/utils.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/interface.ts");
/******/ 	
/******/ })()
;